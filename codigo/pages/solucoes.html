<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Soluções de Desafios</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css">
    <link rel="stylesheet" href="/codigo/assents/css/solucoes.css">
</head>

<body>
    <h1>Soluções  <a href="/codigo/pages/index_homepage.html"><img src ="/codigo/assents/images/logo (2).svg" alt = "Logo"></a></h1>

    <div class="container">
        <div class="row">
            <div id="msg" class="col-sm-10 offset-sm-1 ">
                <!--<div class="alert alert-warning">Contato não encontrado.</div>-->
            </div>
        </div>
        
        <form id="form-solucao">            
            <div class="form-group row">
                <div class="col-sm-8">
                    <select name="filtro_dificuldade" id="filtro_dificuldade" onchange="MostrarSolucao()" class="form-control">
                        <option value="">Selecione a Dificuldade</option>
                        <option value="Fácil">Fácil</option>
                        <option value="Médio">Médio</option>
                        <option value="Díficil">Díficil</option>
                    </select>                    
                </div>
            </div>
        </form>

        <div id="solucao-container" class="row">
            <div class="col-sm-12">
                <div id="nome-desafio" class="font-weight-bold" style="display: none;"></div>
                <pre id="codigo-solucao" class="p-3" style="display: none; background-color: #222; color: #0f0; border: 1px solid #0f0; border-radius: 5px;"></pre>
            </div>
        </div>
    </div>

    <script>
        // Mockup de dados de soluções
        const solucoes = {
            'Fácil': {
                nome: 'Desafio Fácil',
                codigo: `/*desafio 1*/ 
                #include <stdio.h>

int main() {
    int numero;

    // Solicita ao usuário para digitar um número inteiro
    printf("Digite um número inteiro: ");
    scanf("%d", &numero);

    // Verifica se o número é par ou ímpar
    if (numero % 2 == 0) {
        printf("O número %d é par.\n", numero);
    } else {
        printf("O número %d é ímpar.\n", numero);
    }

    return 0;
}


//desafio 2//


import java.util.Scanner;

public class Palindromo {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Solicita ao usuário para digitar um número de 5 dígitos
        System.out.print("Digite um número de 5 dígitos: ");
        int numero = scanner.nextInt();

        // Verifica se o número tem 5 dígitos
        if (numero < 10000 || numero > 99999) {
            System.out.println("O número digitado não tem 5 dígitos.");
        } else {
            // Converte o número para uma string
            String numeroStr = Integer.toString(numero);

            // Verifica se a string é um palíndromo
            boolean isPalindromo = true;
            for (int i = 0; i < numeroStr.length() / 2; i++) {
                if (numeroStr.charAt(i) != numeroStr.charAt(numeroStr.length() - 1 - i)) {
                    isPalindromo = false;
                    break;
                }
            }

            // Exibe se o número é ou não um palíndromo
            if (isPalindromo) {
                System.out.println("O número " + numero + " é um palíndromo.");
            } else {
                System.out.println("O número " + numero + " não é um palíndromo.");
            }
        }

        scanner.close();
    }
}





#desafio 3#



def longest_common_prefix(strs):
    if not strs:
        return ""

    # A função zip(*strs) combina os caracteres das strings posição por posição
    for i, char_group in enumerate(zip(*strs)):
        # Converte o grupo de caracteres para um set para verificar se todos são iguais
        if len(set(char_group)) > 1:
            return strs[0][:i]
    
    # Se o loop terminar sem encontrar diferenças, o prefixo comum é a string mais curta
    return min(strs, key=len)

# Teste da função
strings = ["flower", "flow", "flight"]
print(longest_common_prefix(strings))  # Output: "fl"`
            },
            'Médio': {
                nome: 'Desafio Médio',
                codigo: `/desafio 4*/
            #include <stdio.h>

int main() {
    int A, B, C, temp;

    // Solicita ao usuário para digitar três valores inteiros
    printf("Digite o valor de A: ");
    scanf("%d", &A);
    printf("Digite o valor de B: ");
    scanf("%d", &B);
    printf("Digite o valor de C: ");
    scanf("%d", &C);

    // Processamento para ordenar os valores
    if (A > B) {
        temp = A;
        A = B;
        B = temp;
    }
    if (A > C) {
        temp = A;
        A = C;
        C = temp;
    }
    if (B > C) {
        temp = B;
        B = C;
        C = temp;
    }

    // Imprime os valores ordenados
    printf("Valores ordenados: A = %d, B = %d, C = %d\n", A, B, C);

    return 0;
}



//desafio 5//

import java.util.Random;
import java.util.Scanner;

public class CaraOuCoroa {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Random random = new Random();
        
        int tentativas = 10;
        int acertos = 0;
        int erros = 0;

        for (int i = 0; i < tentativas; i++) {
            System.out.print("Escolha cara (0) ou coroa (1): ");
            int escolha = scanner.nextInt();
            
            if (escolha != 0 && escolha != 1) {
                System.out.println("Escolha inválida! Digite 0 para cara ou 1 para coroa.");
                i--; // Para não contar a tentativa inválida
                continue;
            }

            int resultado = random.nextInt(2); // Gera 0 ou 1 aleatoriamente

            if (escolha == resultado) {
                acertos++;
                System.out.println("Você acertou! Resultado: " + (resultado == 0 ? "Cara" : "Coroa"));
            } else {
                erros++;
                System.out.println("Você errou! Resultado: " + (resultado == 0 ? "Cara" : "Coroa"));
            }
        }

        System.out.println("Fim do jogo!");
        System.out.println("Total de acertos: " + acertos);
        System.out.println("Total de erros: " + erros);
        
        scanner.close();
    }
}


#desafio 6#

from functools import cmp_to_key

def compare(x, y):
    # Compara duas strings x e y concatenadas de ambas as formas possíveis
    if x + y > y + x:
        return -1
    elif x + y < y + x:
        return 1
    else:
        return 0

def largest_number(nums):
    # Converte os números para strings para facilitar a concatenação e comparação
    nums_str = list(map(str, nums))
    
    # Ordena os números com base na comparação personalizada
    nums_str.sort(key=cmp_to_key(compare))
    
    # Junta os números ordenados em uma única string
    result = ''.join(nums_str)
    
    # Remove zeros à esquerda (se houver) e retorna o resultado
    return result if result[0] != '0' else '0'

# Teste da função
nums = [3, 30, 34, 5, 9]
print(largest_number(nums))  # Output: "9534330"`
            },
            'Díficil': {
                nome: 'Desafio Díficil',
                codigo: `/* desafio 7*/
                
                #include <stdio.h>
#include <string.h>

// Função para verificar se uma string é um palíndromo
int isPalindrome(char* s, int len) {
    int i = 0, j = len - 1;
    while (i < j) {
        if (s[i] != s[j]) {
            return 0;
        }
        i++;
        j--;
    }
    return 1;
}

// Função para encontrar o palíndromo mais curto adicionando caracteres no início
char* shortestPalindrome(char* s) {
    int len = strlen(s);
    int i;
    
    // Verifica o maior sufixo que é um palíndromo
    for (i = len; i >= 0; i--) {
        if (isPalindrome(s, i)) {
            break;
        }
    }

    // Cria a nova string resultante
    char* result = (char*)malloc((len + len - i + 1) * sizeof(char));
    int j, k = 0;
    
    // Adiciona os caracteres necessários no início
    for (j = len - 1; j >= i; j--) {
        result[k++] = s[j];
    }
    
    // Copia a string original
    for (j = 0; j < len; j++) {
        result[k++] = s[j];
    }

    result[k] = '\0';
    return result;
}

int main() {
    char s[] = "aacecaaa";
    char* result = shortestPalindrome(s);
    printf("Palíndromo mais curto: %s\n", result);
    free(result);
    return 0;
}


//desafio 8//




import java.util.Stack;

public class BasicCalculator {
    public int calculate(String s) {
        Stack<Integer> stack = new Stack<>();
        int result = 0;
        int number = 0;
        int sign = 1; // 1 significa positivo, -1 significa negativo
        
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            
            if (Character.isDigit(ch)) {
                // Construir o número atual
                number = number * 10 + (ch - '0');
            } else if (ch == '+') {
                // Adicionar o número anterior ao resultado com o sinal correto
                result += sign * number;
                number = 0; // Resetar o número
                sign = 1; // Definir o próximo sinal como positivo
            } else if (ch == '-') {
                // Adicionar o número anterior ao resultado com o sinal correto
                result += sign * number;
                number = 0; // Resetar o número
                sign = -1; // Definir o próximo sinal como negativo
            } else if (ch == '(') {
                // Empurrar o resultado atual e o sinal para a pilha
                stack.push(result);
                stack.push(sign);
                // Resetar resultado e sinal para a nova subexpressão
                result = 0;
                sign = 1;
            } else if (ch == ')') {
                // Adicionar o número anterior ao resultado com o sinal correto
                result += sign * number;
                number = 0; // Resetar o número
                // Multiplicar o resultado atual pelo sinal anterior
                result *= stack.pop();
                // Adicionar ao resultado acumulado anteriormente
                result += stack.pop();
            }
        }
        
        // Adicionar o último número ao resultado
        if (number != 0) {
            result += sign * number;
        }
        
        return result;
    }

    public static void main(String[] args) {
        BasicCalculator calculator = new BasicCalculator();
        String expression = "1 + 1";
        System.out.println("Resultado: " + calculator.calculate(expression)); // Output: 2
        
        expression = "2-1 + 2";
        System.out.println("Resultado: " + calculator.calculate(expression)); // Output: 3
        
        expression = "(1+(4+5+2)-3)+(6+8)";
        System.out.println("Resultado: " + calculator.calculate(expression)); // Output: 23
    }
}    
`
            }
        };

        function MostrarSolucao() {
            const dificuldade = document.getElementById('filtro_dificuldade').value;
            const solucaoContainer = document.getElementById('solucao-container');
            const nomeDesafio = document.getElementById('nome-desafio');
            const codigoSolucao = document.getElementById('codigo-solucao');
            
            if (dificuldade && solucoes[dificuldade]) {
                nomeDesafio.style.display = 'block';
                codigoSolucao.style.display = 'block';
                nomeDesafio.textContent = solucoes[dificuldade].nome;
                codigoSolucao.textContent = solucoes[dificuldade].codigo;
            } else {
                nomeDesafio.style.display = 'none';
                codigoSolucao.style.display = 'none';
                nomeDesafio.textContent = '';
                codigoSolucao.textContent = '';
            }
        }
    </script>
</body>

</html>